require 'rake'
require 'rubygems'

ROOT = File.expand_path('.')
SRC = ROOT
CONTENT = File.join(SRC, 'chrome', 'content')
DST = File.join(ROOT, 'build')
TMP = File.join(ROOT, 'tmp')

unless defined? OSX then
  OSX = PLATFORM =~ /darwin/
  WIN = PLATFORM =~ /win32/
  NIX = !(OSX || WIN)
end

begin
  require 'term/ansicolor'
  include Term::ANSIColor
rescue LoadError
  raise 'Run "gem install term-ansicolor"'
end
# http://kpumuk.info/ruby-on-rails/colorizing-console-ruby-script-output/
if WIN then
  begin
    require 'win32console'
    include Win32::Console::ANSI
  rescue LoadError
    raise 'Run "gem install win32console" to use terminal colors on Windows'
  end
end

#
# you can use FileUtils: http://corelib.rubyonrails.org/classes/FileUtils.html
#
require 'find'

def file_color(text); yellow(text); end
def dir_color(text); blue(text); end
def cmd_color(text); green(text); end

# copies directory tree without .svn, .git and other temporary files
def cp_dir(src, dst)
  puts "#{cmd_color('copying')} #{dir_color(src)}"
  puts "     -> #{dir_color(dst)}"
  Find.find(src) do |fn|
    next if fn =~ /\/\./
    r = fn[src.size..-1]
    if File.directory? fn
      mkdir File.join(dst,r) unless File.exist? File.join(dst,r)
    else
      cp(fn, File.join(dst,r))
    end
  end
end

def cp_file(src, dst)
  puts "#{cmd_color('copying')} #{file_color(src)}"
  puts "     -> #{file_color(dst)}"
  cp(src, dst)
end

def dep(src)
  s = File.expand_path src
  rs = s[SRC.size..-1]
  d = File.join(TMP, rs)
  puts "#{cmd_color('copying')} #{file_color(s)}"
  puts "     -> #{file_color(d)}"
  cp(s, d)
end

def my_mkdir(dir)
  puts "#{cmd_color('creating directory')} #{dir_color(dir)}"
  mkdir dir
end

def parse_version()
  f = File.new(File.join(SRC, 'install.rdf'))
  text = f.read
  unless text=~/<em:version>([^<]*)<\/em:version>/
    puts "#{red('Version not found')}"
    exit
  end
  $1
end

################################################################################

desc "prepare release XPI"
task :release do
  version = parse_version()
  $stderr = File.new('/dev/null', 'w') unless ENV["verbose"]

  remove_dir(TMP) if File.exists?(TMP) # recursive!
  mkdir(TMP)
  cp_dir(File.join(SRC, 'chrome'), File.join(TMP, "chrome"))
  cp_dir(File.join(SRC, 'defaults'), File.join(TMP, "defaults"))
  dep(File.join(SRC, 'chrome.manifest'))
  dep(File.join(SRC, 'install.rdf'))
  dep(File.join(SRC, 'license.txt'))
  `rm -rf "#{File.join(TMP, "chrome", "content", "codemirror")}"` # codemirror files are not needed, scripts should include generated codemirror.js
  my_mkdir(DST) unless File.exist?(DST)

  res = "#{DST}/firerainbow-#{version}.xpi"
  File.unlink(res) if File.exists?(res)
  puts "#{cmd_color('zipping')} #{file_color(res)}"
  Dir.chdir(TMP) do
    puts red('need zip on command line (download http://www.info-zip.org/Zip.html)') unless system("zip -r \"#{res}\" *");
  end
  remove_dir(TMP) if File.exist?(TMP) # recursive!
end

desc "generate sandboxed codemirror source"
task :sandbox do
    sources = ["util.js", "tokenize.js", "tokenizejavascript.js", "parsejavascript.js", "parsecss.js", "parsexml.js", "parsehtmlmixed.js","stringstream.js"]
    output = File.join(CONTENT, "codemirror.js")
    
    text = "// !!! DO NOT EDIT THIS FILE (GENERATED) !!!\n"
    text += "// this file was generated from codemirror subdirectory by `rake sandbox` task\n"
    text += "\n"
    text += "\n"

    license_lines = File.new(File.join(CONTENT, 'codemirror', 'LICENSE')).readlines
    license_lines.map! do |line| 
        "// " + line
    end
    text += license_lines.join

    text += "\n"
    text += "\n"
    
    # isolate codemirror into separate namespace
    text += "var codemirror = (function() {\n"
    text += "var Editor = {};var indentUnit = 2;var window=this;\n"
    
    sources.each do |source|
        text += File.new(File.join(CONTENT, 'codemirror', source)).read + "\n"
    end

    text += "   return this;\n"
    text += "})();\n"

    # do some souce code hacks
    text.gsub!("var JSParser", "this.JSParser")
    text.gsub!("var HTMLMixedParser", "this.HTMLMixedParser")
    text.gsub!("var XMLParser", "this.XMLParser")
    text.gsub!("var CSSParser", "this.CSSParser")
    text.gsub!("var stringStream", "this.stringStream")
    text.gsub!("var StopIteration", "this.StopIteration")
    text.gsub!("function forEach", "this.forEach = function")
    
    File.open(output, 'w') do |f| 
        f.write(text)
    end
end

task :default => :release